#!/usr/bin/perl
## ----------------------------------------------------------------------
## This script converts a verilog file into a ruby includable file which
## contains the structure which defines the module definition of the given
## verilog file.
##
##  Input:  Path to the verilog file
##          Parameter override declarations in format PARAM1=value
##          Class override declared using -class flag
##  Output: File in same directory as verilog file named <module>.rb
##          or <class_override>.rb if -class flag specified.
##
##  Examples:
##     vscan subdir1/leaf.v
##     vscan PARAM1=7 PARAM2=9 leaf.v
##     vscan -class trunk leaf.v
## ----------------------------------------------------------------------

require 5.005;
use FindBin qw($RealBin);
use lib "$RealBin/blib/arch";
use lib "$RealBin/blib/lib";
use lib "$RealBin";

use Verilog::Netlist;
use strict;

my $VERSION = "0.1.0";
my %PARAMETERS;
my $class_override = "";
my $verilog_file = "";
my $ruby_file = "";

while( @ARGV ) {
    my $option = shift @ARGV;
    if( $option =~ /=/ ) {
        ## A parameter is potentially being overwritten
        (my $parameter, my $value) = split( /=/, $option, 2 );
        $PARAMETERS{$parameter} = $value;
    }
    elsif( $option eq "-class" ) {
        die "error: you can't specify more than one class overide.\n" if( $class_override );
        $class_override = shift @ARGV;
    }
    else {
        die "error: too many command line arguments.\n" if( $verilog_file );
        $verilog_file = $option;
        $ruby_file = $verilog_file;
        $ruby_file =~ s/\.(.*?)v$/.rb/;
    }
}
die "error: you must supply a leaf verilog module.\n" unless( $verilog_file );
die "error: file $verilog_file does not exist.\n" unless( -f $verilog_file );
my $module;
if( $verilog_file =~ /^.*\/(.*?)\.(.*?)v.*$/ ) {
    ## path includes hierarchy
    $module = $1;
    $ruby_file =~ s/\/${module}\.rb$/\/${class_override}\.rb/ if( $class_override );
} else {
    ## file is in CWD
    $module = $verilog_file;
    $module =~ s/\.(.*?)v$//;
    $ruby_file = "${class_override}.rb" if( $class_override );
}

## And then process the Verilog file
&Convert_Verilog_To_Ruby( $module, $class_override, $verilog_file, $ruby_file );
exit(0);

## --------------------------------------------------
## Parse a verilog file and convert it into a ruby executable
## that contains the structure which described the Verilog module's
## declaration state
sub Convert_Verilog_To_Ruby {
    my $module_name = shift @_;
    my $class = shift @_;
    my $in_file = shift @_;
    my $out_file = shift @_;

    ## Prepare for reading in verilog netlists
    my $netlist = new Verilog::Netlist();
    $netlist->read_file( filename=>$in_file );

    ## Open the output file for writing
    open( RUBY, "> $out_file" ) or die "error: can't write file $out_file: $!\n";
    ## And print any startup text needed
    &Print_Header($VERSION);

    ## Get a pointer to the module's structure
    foreach my $module ($netlist->modules_sorted) {

        ## Add the module name and class
        $class = $module->name unless( $class );
        &Print_Module($in_file, $class, $module->name);

        ## Add override parameters
        &Print_Parameters();
    
        ## And information for each port
        foreach my $port ($module->ports_sorted) {
            (my $vector, my $lhs, my $rhs) = &Parse_Vector($port->data_type, $module);
            &Print_Port($port->name, $port->direction, $vector, $lhs, $rhs);
        }
        
        ## Finish with any text required to end file creation
        &Print_Trailer();

    }
        
    return;
}

## --------------------------------------------------
## A function to determine if a string is a Verilog vector
## declaration (e.g., [3:2]) and return the LSB of the
## vector and the width of the vector.
sub Parse_Vector {
    my $string = shift @_;
    my $module = shift @_;
    my $vector;
    my $lhs;
    my $rhs;
    my $type;

    $string =~ s/\/\/.*$//; ## Remove Verilog comments if any

    ## First determine the type
    if   ( $string =~ /^reg/       ) { $type = "reg";       }
    elsif( $string =~ /^logic/     ) { $type = "logic";     }
    elsif( $string =~ /^bit/       ) { $type = "bit";       }
    elsif( $string =~ /^byte/      ) { $type = "byte";      }
    elsif( $string =~ /^shortint/  ) { $type = "shortint";  }
    elsif( $string =~ /^int/       ) { $type = "int";       }
    elsif( $string =~ /^longint/   ) { $type = "longint";   }
    elsif( $string =~ /^time/      ) { $type = "time";      }
    elsif( $string =~ /^realtime/  ) { $type = "realtime";  }
    elsif( $string =~ /^shortreal/ ) { $type = "shortreal"; }
    elsif( $string =~ /^real/      ) { $type = "real";      }
    else                             { $type = "wire";      }

    ## And then determine width of signal based on type, etc.
    if( $type eq "byte" ) {
        ## byte
        $vector = 1;
        $lhs = 7;
        $rhs = 0;
    }
    elsif( $type eq "shortint" ) {
        ## integer
        $vector = 1;
        $lhs = 15;
        $rhs = 0;
    }
    elsif( ($type eq "int") || ($type eq "shortreal") ) {
        ## integer, shortreal
        $vector = 1;
        $lhs = 31;
        $rhs = 0;
    }
    elsif( ($type =~ /^real/) || ($type eq "longint") || ($type eq "time") ) {
        ## real, realtime, longint, time
        $vector = 1;
        $lhs = 63;
        $rhs = 0;
    }
    elsif( $string =~ /:/ ) {
        ## reg, wire, logic, bit:
	## vector containing parameters, mathematical functions, etc.
        $vector = 1;
        $string =~ s/^.*\[//; ## strip everything up to and including [
        $string =~ s/\].*$//; ## strip everything after and including ]
        ## Break into the LHS and RHS (of the colon)
        ($lhs, $rhs) = split( /:/, $string, 2 );
        ## Convert each side into a numerical value
        $lhs = &Resolve_Expression( $lhs, $module );
        $rhs = &Resolve_Expression( $rhs, $module );
    } else {
        ## reg, wire, logic, bit: single-bit
        $vector = 0;
        $lhs = 0;
        $rhs = 0;
    }

    return( $vector, $lhs, $rhs );
}

## --------------------------------------------------
## Function to replace parameters in a string and then
## evaluate the mathematical result of the string post
## parameter replacement.
sub Resolve_Expression {
    my $string = shift @_;
    my $module = shift @_;

    ## Split the string on interesting Verilog supported mathematical operators
    ##   (which are: **, *, +, -, /, %, (, ) ).  Note, $clog() is supported deeper
    ##   in the code below.
    my @ITEMS = split( /(\*+|\+|\-|\/|\%|\(|\))/, $string );
    ## Then substitute parameters with values (i.e., if one of
    ## the items returned by the 'split' above is a defined
    ## parameter, replace it in the array with the parameters value:
    for( my $i=0; $i<=$#ITEMS; ++$i ) {
        ## Is there an override of item from the command line?
        ## if so, replace with the override value instead
        if( $PARAMETERS{$ITEMS[$i]} ) {
            ## Use override value
            $ITEMS[$i] = $PARAMETERS{$ITEMS[$i]};
        }
	elsif( $ITEMS[$i] eq "\$clog2" ) {
	    ## Else, check if the item is a special Verilog function call:
	    ## Replace verilog log-base-2 function call with local version
	    $ITEMS[$i] = "&Log2";
	}
        else {
            ## Else, check if there there is a net matching the text 'name' of the item?
            my $net = $module->find_net($ITEMS[$i]);
            ## If so, replace the item with the value of the net (parameter)
            $ITEMS[$i] = $net->value if( $net );
        }
	## Else, the item is either a number, mathematical operator, or something
	## that is not supported.  Leave it unchanged.
    }
    ## Then evaluate the resultant string as a mathematical function.  This will return
    ## a NULL value if the evaluation fails (due to unsupported stuff in expression):
    ## Because this is a PERL EVAL, the &Log2 function call that was placed in the expression
    ## will calculate using the Log2 subroutine located in this program.
    my $result = eval( join( "", @ITEMS ) );
    die "error: I/O declaration using undefined parameter.\n" unless( $result ne "" );

    return($result);
}

## --------------------------------------------------
## Ruby file header text
sub Print_Header {
    print RUBY "# vscan v${VERSION}\n";
    print RUBY "\n";
    return;
}

## --------------------------------------------------
## Ruby file module name processing
sub Print_Module {
    my $src_file = shift @_;
    my $class_name = shift @_;
    my $module_name = shift @_;
    print RUBY "# --------------------------------------------------\n";
    ## Make sure class name is all lower case with first letter capitalized
    $class_name =~ tr/A-Z/a-z/;
    $class_name = ucfirst( $class_name );
    print RUBY "class $class_name < HdlModule\n";
    print RUBY "  def initialize\n";
    print RUBY "    proxy = true\n";
    print RUBY "    file_name = \"${src_file}\"\n";
    print RUBY "    module_name = \"${module_name}\"\n";

    return;
}

## --------------------------------------------------
## Print out override parameters specified on the command line
sub Print_Parameters {
    foreach my $override (sort keys %PARAMETERS) {
        print RUBY "    parameter[\"${override}\"] = " . $PARAMETERS{$override} . "\n";
    }

    return;
}

## --------------------------------------------------
## Ruby file port data type processing
sub Print_Port {
    my $port_name = shift @_;
    my $port_dir = shift @_;
    my $vector = shift @_;
    my $vector_lhs = shift @_;
    my $vector_rhs = shift @_;

    ## Convert the port direction into a proper string
    $port_dir = "input" if( $port_dir eq "in" );
    $port_dir = "output" if( $port_dir eq "out" );
    ## if 'inout', already in correct format

    ## And print out the lhs/rhs of vectors if the port is a vector
    if( $vector ) {
        print RUBY "    add_port \"${port_name}\", direction: \"${port_dir}\", lhs: ${vector_lhs}, rhs: ${vector_rhs}\n";
    } else {
        print RUBY "    add_port \"${port_name}\", direction: \"${port_dir}\"\n";
    }

    return;
}

## --------------------------------------------------
## Ruby file trailer text
sub Print_Trailer {
    print RUBY "  end\n";
    print RUBY "end\n";
    print RUBY "\n";

    return;
}

## --------------------------------------------------
## Log2 function used for signal vector resolution.  In order to
## match verilog, round up the answer
sub Log2 {
    my $operand = shift @_;
    my $result = &RoundUp( log($operand)/log(2) );

    return( $result );
}

## --------------------------------------------------
## Helper function to round up a value
sub RoundUp {
    my $n = shift @_;
    my $n_roundedup = ($n==int($n)) ? $n : int($n+1);

    return( $n_roundedup );
}

